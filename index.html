// worker.ts - Final version with location search, hierarchical matching, and updated add/list endpoints.

export default {
    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
        const db = env.DB;
        const url = new URL(request.url);
        const pathname = url.pathname.replace(/\/$/, ""); // Normalize pathname by removing trailing slash
        const method = request.method.toUpperCase();

        const CORS_HEADERS = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        };

        if (method === "OPTIONS") {
            return new Response(null, { status: 204, headers: CORS_HEADERS });
        }

        const jsonResponse = (obj: any, status: number = 200): Response =>
            new Response(JSON.stringify(obj), {
                status,
                headers: { ...CORS_HEADERS, "Content-Type": "application/json" },
            });

        async function parseBody(req: Request): Promise<any> {
            const contentType = req.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
                return await req.json().catch(() => ({}));
            }
            if (contentType.includes("application/x-www-form-urlencoded")) {
                const formData = await req.formData();
                const out: { [key: string]: any } = {};
                for (const [key, value] of formData.entries()) {
                    out[key] = value;
                }
                return out;
            }
            try {
                return await req.json();
            } catch (e) {
                return {};
            }
        }

        const action = (url.searchParams.get("action") || "").toLowerCase();

        // Helper to parse Type: ... from additionalinfo (legacy parsing, still useful for old entries)
        function extractTypeFromNotes(additionalinfo: string | null | undefined): string | null {
            if (!additionalinfo || typeof additionalinfo !== "string") return null;
            const match = additionalinfo.match(/Type:\s*(shipper|traveller)/i);
            return match ? match[1].toLowerCase() : null;
        }

        // --- NEW: Location Search Endpoint ---
        if (
            (method === "GET" && (pathname === "/search-locations" || pathname.endsWith("/search-locations"))) ||
            (method === "GET" && action === "search-locations")
        ) {
            const query = (url.searchParams.get("query") || "").trim();
            if (!query || query.length < 2) {
                return jsonResponse([]);
            }

            const searchTerm = `%${query.toLowerCase()}%`;
            try {
                const { results } = await db.prepare(
                    "SELECT val, cc, type, label FROM locations WHERE LOWER(val) LIKE ?1 OR LOWER(label) LIKE ?1 ORDER BY type DESC, val ASC LIMIT 10"
                ).bind(searchTerm)
                 .all();
                return jsonResponse(results);
            } catch (err: any) {
                return jsonResponse({ status: "error", message: `Failed to search locations: ${String(err.message || err)}` }, 500);
            }
        }
        // --- END NEW: Location Search Endpoint ---

        // ---------------- LIST with filters (UPDATED for new location fields) ----------------
        if (
            (method === "GET" && (pathname === "/list" || pathname.endsWith("/list"))) ||
            (method === "GET" && action === "list")
        ) {
            try {
                const queryParams = url.searchParams;

                // Extract search parameters, including the new ones for hierarchical matching
                const f_type = (queryParams.get("type") || "").trim().toLowerCase();
                const f_date = (queryParams.get("datepickup") || "").trim();

                const f_from_val = (queryParams.get("from") || "").trim();
                const f_from_country = (queryParams.get("from_country") || "").trim();
                const f_from_type = (queryParams.get("from_type") || "").trim().toLowerCase();

                const f_to_val = (queryParams.get("to") || "").trim();
                const f_to_country = (queryParams.get("to_country") || "").trim();
                const f_to_type = (queryParams.get("to_type") || "").trim().toLowerCase();

                let whereClauses = [`(status IS NULL OR status='' OR UPPER(status)='OPEN')`];
                let bindParams: (string | number)[] = [];

                if (f_type) {
                    whereClauses.push("LOWER(type) = ?");
                    bindParams.push(f_type);
                }
                if (f_date) {
                    whereClauses.push("datepickup = ?");
                    bindParams.push(f_date);
                }

                // --- HIERARCHICAL LOCATION MATCHING FOR 'FROM' ---
                if (f_from_val) { // Proceed if there's any 'from' value
                    if (f_from_country && f_from_type) { // If specific country/type is selected
                        let fromClause = `
                            (
                                (from_country = ? AND (from_loc = ? OR from_type = 'country' OR ? = 'country'))
                                OR (from_country IS NULL AND LOWER(from_loc) LIKE ?) -- Fallback for old/unspecified requests matching on text
                            )
                        `;
                        whereClauses.push(fromClause);
                        bindParams.push(f_from_country, f_from_val, f_from_type, `%${f_from_val.toLowerCase()}%`);
                    } else { // Fallback if only text 'from' is provided (e.g., initial typing or old entries)
                        whereClauses.push("LOWER(from_loc) LIKE ?");
                        bindParams.push(`%${f_from_val.toLowerCase()}%`);
                    }
                }

                // --- HIERARCHICAL LOCATION MATCHING FOR 'TO' ---
                if (f_to_val) { // Proceed if there's any 'to' value
                    if (f_to_country && f_to_type) { // If specific country/type is selected
                        let toClause = `
                            (
                                (to_country = ? AND (to_loc = ? OR to_type = 'country' OR ? = 'country'))
                                OR (to_country IS NULL AND LOWER(to_loc) LIKE ?) -- Fallback for old/unspecified requests matching on text
                            )
                        `;
                        whereClauses.push(toClause);
                        bindParams.push(f_to_country, f_to_val, f_to_type, `%${f_to_val.toLowerCase()}%`);
                    } else { // Fallback if only text 'to' is provided
                        whereClauses.push("LOWER(to_loc) LIKE ?");
                        bindParams.push(`%${f_to_val.toLowerCase()}%`);
                    }
                }
                // --- END HIERARCHICAL LOCATION MATCHING ---

                const sql = `
                    SELECT id, name, from_loc, to_loc, datepickup, mobile, email,
                           additionalinfo, status, createdat, price_per_kg, type,
                           from_country, to_country, from_type, to_type
                    FROM requests
                    WHERE ${whereClauses.join(" AND ")}
                    ORDER BY datepickup ASC, createdat DESC
                `;

                const q = await db.prepare(sql).bind(...bindParams).all();
                return jsonResponse(q.results || []);

            } catch (err: any) {
                return jsonResponse({ status: "error", message: `Failed to list requests: ${String(err.message || err)}` }, 500);
            }
        }

        // ---------------- GET by id (UPDATED for new location fields) ----------------
        if ((method === "GET" && (pathname === "/get" || pathname.endsWith("/get"))) || (method === "GET" && action === "get")) {
            const id = url.searchParams.get("id") || (pathname.split("/get/")[1] || "");
            if (!id) return jsonResponse({ status: "error", message: "ID missing" }, 400);
            try {
                const q = await db.prepare(
                    `SELECT id, name, from_loc, to_loc, datepickup, mobile, email, additionalinfo, status, createdat, price_per_kg, type, from_country, to_country, from_type, to_type
                     FROM requests WHERE id = ?`
                ).bind(id).all();
                if (!q.results || q.results.length === 0) return jsonResponse({ status: "error", message: "Not found" }, 404);
                const row = q.results[0] as Record<string, any>;
                // Ensure type and price_per_kg are correctly set if they were null/undefined
                if (!row.type) row.type = extractTypeFromNotes(row.additionalinfo) || null;
                if (typeof row.price_per_kg === "undefined") row.price_per_kg = null; // Normalize to null if not present
                return jsonResponse(row);
            } catch (err: any) {
                return jsonResponse({ status: "error", message: `Failed to get request: ${String(err.message || err)}` }, 500);
            }
        }

        // ---------------- ADD (create) (UPDATED for new location fields) ----------------
        if (method === "POST" && (pathname === "/add-request" || pathname.endsWith("/add") || action === "add")) {
            const body = await parseBody(request);

            const name = body.name || "";
            const from_loc = body.from || ""; // Use 'from' (val) from frontend
            const to_loc = body.to || "";     // Use 'to' (val) from frontend
            const datepickup = body.datepickup || "";
            const price_per_kg = (body.price_per_kg !== undefined && body.price_per_kg !== '') ? parseFloat(body.price_per_kg) : null;
            const mobile = body.mobile || "";
            const email = body.email || "";
            const additionalinfo = body.additionalinfo || "";
            const type = (body.type || "").toLowerCase() || null;

            // NEW: Get the country code and type from the frontend's hidden inputs
            const from_country = body.from_country || "";
            const to_country = body.to_country || "";
            const from_type = (body.from_type || "").toLowerCase();
            const to_type = (body.to_type || "").toLowerCase();

            // Enhanced validation for new fields
            if (!name || !from_loc || !to_loc || !datepickup || !type || !from_country || !to_country || !from_type || !to_type) {
                return jsonResponse({ status: "error", message: "Missing required fields (name, from, to, datepickup, type, and full location details: from_country, to_country, from_type, to_type)." }, 400);
            }

            // More robust ID generation
            const id = "R" + Date.now().toString().slice(-8) + Math.random().toString(36).substring(2, 6).toUpperCase();
            const createdAt = new Date().toISOString();

            try {
                await db.prepare(
                    `INSERT INTO requests (id, name, from_loc, to_loc, datepickup, price_per_kg, mobile, email, additionalinfo, status, createdat, type, from_country, to_country, from_type, to_type)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
                )
                .bind(
                    id, name, from_loc, to_loc, datepickup, price_per_kg, mobile, email,
                    additionalinfo, "OPEN", createdAt, type, from_country, to_country, from_type, to_type
                )
                .run();

                return jsonResponse({ status: "ok", id });
            } catch (err: any) {
                return jsonResponse({ status: "error", message: `Failed to add request: ${String(err.message || err)}` }, 500);
            }
        }

        // ---------------- CLOSE ----------------
        if (method === "POST" && (pathname === "/close-request" || pathname.endsWith("/close") || action === "close")) {
            const body = await parseBody(request);
            const id = body.id || url.searchParams.get("id") || (pathname.split("/close/")[1] || "");
            if (!id) return jsonResponse({ status: "error", message: "ID missing" }, 400);
            try {
                const r = await db.prepare(`UPDATE requests SET status = ? WHERE id = ?`).bind("CLOSED", id).run();
                return jsonResponse({ status: "ok", changed: r.changes || 0 });
            } catch (err: any) {
                return jsonResponse({ status: "error", message: `Failed to close request: ${String(err.message || err)}` }, 500);
            }
        }

        return jsonResponse({ status: "ok", message: "Worker running. Use /list, /get?id=, /add-request, /close-request, /search-locations or ?action=list/add/close/search-locations" });
    },
};

// Optional: Define interfaces for better TypeScript type checking
// Ensure these are consistent with your D1 schema
interface Env {
    DB: D1Database;
}

interface D1Database {
    prepare(query: string): D1PreparedStatement;
}

interface D1PreparedStatement {
    bind(...values: (string | number | null)[]): D1PreparedStatement;
    first<T = Record<string, any>>(colName?: string): Promise<T | null>;
    run(): Promise<D1Result>;
    all<T = Record<string, any>>(): Promise<D1Result<T[]>>;
    raw<T = Record<string, any>>(): Promise<T[][]>;
}

interface D1Result<T = any> {
    success: boolean;
    error?: string;
    results?: T;
    changes?: number;
    duration?: number;
    lastRowId?: number;
}

interface ExecutionContext {
    waitUntil(promise: Promise<any>): void;
    passThroughOnException(): void;
}
